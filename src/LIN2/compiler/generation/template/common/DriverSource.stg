boolReadImplementation(signal) ::= <<
l_bool l_bool_rd_<signal.name>() {
    return (l_bool)((frames[<signal.frame.name>_INDEX].data.scalar >\> <signal.offset>) & <signal.signalMask.hex>ULL);
}>>

u8ReadImplementation(signal) ::= <<
l_u8 l_u8_rd_<signal.name>() {
    return (l_u8)((frames[<signal.frame.name>_INDEX].data.scalar >\> <signal.offset>) & <signal.signalMask.hex>ULL);
}>>

u16ReadImplementation(signal) ::= <<
l_u16 l_u16_rd_<signal.name>() {
    return (l_u16)((frames[<signal.frame.name>_INDEX].data.scalar >\> <signal.offset>) & <signal.signalMask.hex>ULL);
}>>

bytesReadImplementation(signal) ::= <<
void l_bytes_rd_<signal.name>(l_u8 start,l_u8 count,l_u8* const data) {
    // TODO check for count being to large??
    for(l_u8 i=0;i\<count;++i)
        data[i] = frames[<signal.frame.name>_INDEX].data[<signal.offset>/8+start+i];
}>>


boolWriteImplementation(signal) ::= <<
void l_bool_wr_<signal.name>(l_bool v) {
    frames[<signal.frame.name>_INDEX].data.scalar &= ~(<signal.signalMask.hex>ULL \<\< <signal.offset>);
    frames[<signal.frame.name>_INDEX].data.scalar |= (((uint64_t)v & <signal.signalMask.hex>ULL) \<\< <signal.offset>);
    <signal.name>_flag = true;
}>>

u8WriteImplementation(signal) ::= <<
void l_u8_wr_<signal.name>(l_u8 v) {
    frames[<signal.frame.name>_INDEX].data.scalar &= ~(<signal.signalMask.hex>ULL \<\< <signal.offset>);
    frames[<signal.frame.name>_INDEX].data.scalar |= (((uint64_t)v & <signal.signalMask.hex>ULL) \<\< <signal.offset>);
    <signal.name>_flag = true;
}>>

u16WriteImplementation(signal) ::= <<
void l_u16_wr_<signal.name>(l_16 v) {
    frames[<signal.frame.name>_INDEX].data.scalar &= ~(<signal.signalMask.hex>ULL \<\< <signal.offset>);
    frames[<signal.frame.name>_INDEX].data.scalar |= (((uint64_t)v & <signal.signalMask.hex>ULL) \<\< <signal.offset>);
    <signal.name>_flag = true;
}>>

bytesWriteImplementation(signal) ::= <<
void l_bytes_wr_<signal.name>(l_u8 start,l_u8 count,const l_u8* const data) {
    frames[<signal.frame.name>_INDEX].data.scalar &= ~(<signal.signalMask.hex>ULL \<\< <signal.offset>);
    frames[<signal.frame.name>_INDEX].data.scalar |= (((uint64_t)v & <signal.signalMask.hex>ULL) \<\< <signal.offset>);
    <signal.name>_flag = true;
}>>


signalFlagImplementation(signal) ::= <<
l_bool l_flg_tst_<signal.name>() {
    return <signal.name>_flag;
}

void l_flg_clr_<signal.name>() {
    <signal.name>_flag = false;
}
>>

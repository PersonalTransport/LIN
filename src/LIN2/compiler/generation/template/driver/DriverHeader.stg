driverHeader(node) ::= <<
#ifndef <node.name>_DRIVER_H
#define <node.name>_DRIVER_H

#include \<stdlib.h>
#include \<stdint.h>
#include \<stdbool.h>

typedef bool l_bool;        //- 0 is false, and non-zero (>0) is true.
typedef uint8_t l_u8;       //- Unsigned 8 bit integer.
typedef uint16_t l_u16;     //- Unsigned 16 bit integer.

<if(node.master)>
struct l_schedule;

extern struct l_schedule _L_NULL_SCHEDULE;
<node.scheduleTables:{schedule|extern struct l_schedule _<schedule.name>;};separator="\n">

#define L_NULL_SCHEDULE &_L_NULL_SCHEDULE
<node.scheduleTables:{schedule|#define <schedule.name> &_<schedule.name>};separator="\n">
<endif>

<node.signals:{signal|<signalFlagPrototype(signal)>};separator="\n\n">

<node.publishedSignals:{signal|<signal:(signal.signalType_WritePrototype)()>};separator="\n\n">

<node.signals:{signal|<signal:(signal.signalType_ReadPrototype)()>};separator="\n\n">

l_bool l_sys_init();

l_bool l_ifc_init_UART1();

void l_ifc_tx_UART1();

void l_ifc_rx_UART1();
<if(node.master)>

void l_sch_set_UART1(struct l_schedule *schedule,l_u8 entry);

l_u8 l_sch_tick_UART1();
<endif>

#endif // <node.name>_DRIVER_H
>>

boolReadPrototype(signal) ::= "l_bool l_bool_rd_<signal.name>();"
u8ReadPrototype(signal) ::= "l_u8 l_u8_rd_<signal.name>();"
u16ReadPrototype(signal) ::= "l_u16 l_u16_rd_<signal.name>();"
bytesReadPrototype(signal) ::= "void l_bytes_rd_<signal.name>(l_u8 start,l_u8 count,l_u8* const data);"

boolWritePrototype(signal) ::= "void l_bool_wr_<signal.name>(l_bool v);"
u8WritePrototype(signal) ::= "void l_u8_wr_<signal.name>(l_u8 v);"
u16WritePrototype(signal) ::= "void l_u16_wr_<signal.name>(l_u16 v);"
bytesWritePrototype(signal) ::= "void l_bytes_wr_<signal.name>(l_u8 start,l_u8 count,const l_u8* const data);"

signalFlagPrototype(signal) ::= <<
l_bool l_flg_tst_<signal.name>();

void l_flg_clr_<signal.name>();
>>

driverSource(node) ::= <<
#include \<<node.name>.h>
#include \<xc.h>

#define MIN_BAUD 10000
#define MAX_BAUD 20000

#if (13*FCY/MIN_BAUD)  > 0xFFFF
#   error "FCY/MAX_BAUD is too large for a 16-bit timer!"
#endif

#define L_FRAME_PID(id) (~((id \<\< 6) ^ (id \<\< 4) ^ (id \<\< 3) ^ (id \<\< 2)) & 0x80) |\
                         (((id \<\< 6) ^ (id \<\< 5) ^ (id \<\< 4) ^ (id \<\< 2)) & 0x40) |\
                         (id & 0x3F)

<node.frames:{frame|#define <frame.name>_INDEX <i0>};separator="\n">

enum l_buffer_state {
    L_BREAK_SYNC,
    L_PID,
    L_DATA,
    L_CHECKSUM,
    L_IDLE
};

struct l_frame {
    l_u8 PID;
    union {
        l_u8 array[8];
        uint64_t scalar;
    } data;
};

enum service_identifier {
    // 0 - 0xAF reserved
    ASSIGN_NAD = 0xB0,
    ASSIGN_FRAME_IDENTIFIER = 0xB1, // Obsolete??
    READ_BY_IDENTIFIER = 0xB2,
    CONDITIONAL_CHANGE_NAD = 0xB3,
    DATA_DUMP = 0xB4,
    // 0xB5 reserved
    SAVE_CONFIGURATION = 0xB6,
    ASSIGN_FRAME_IDENTIFIER_RANGE = 0xB7,
    // 0xB8 - 0xFF reserved
};

<if(node.master)>
enum l_schedule_entry_type {
    ASSIGN_FRAME_ID_ENTRY,//??
    ASSIGN_FRAME_ID_RANGE_ENTRY,
    ASSIGN_NAD_ENTRY,
    CONDITIONAL_CHANGE_NAD_ENTRY,//??
    //!!DATA_DUMP_ENTRY,
    FREE_FORMAT_ENTRY,//??
    MASTER_REQ_ENTRY,
    SAVE_CONFIGURATION_ENTRY,
    SLAVE_RESP_ENTRY,
    UNCONDITIONAL_ENTRY
};

struct l_schedule_entry {
    enum l_schedule_entry_type type; // TODO could be 4 bit unsigned
    l_u8 ticks;
    union {
        struct l_frame *frame; // TODO change to PID!
        //TODO add others
    } data;
};

struct l_schedule {
    l_u8 size;
    struct l_schedule_entry *entries;
};

struct l_schedule_instance {
    struct l_schedule *schedule;
    l_u8 tick;
    l_u8 index;
    struct l_schedule_entry *entry;
};
<endif>

static struct {
    enum l_buffer_state state;
    l_u8 PID;
    union {
            l_u8 array[8];
            uint64_t scalar;
    } data;
    l_u8 checksum;
    l_u8 size;
    l_u8 index;
} tx_buffer, rx_buffer;

static struct l_frame frames[] = {
<node.frames:{frame|
    {   // <frame.name>
        .PID = L_FRAME_PID(<frame.ID>),
        .data.scalar = 0ULL // TODO initial data
    \}};separator=",\n">
};

<if(node.master)>
struct l_schedule _L_NULL_SCHEDULE = {0,NULL};

<node.scheduleTables:{schedule|
static struct l_schedule_entry _<schedule.name>_entries[] = {
    <schedule.entries:{entry|<entry:(entry.polymorphic_Initialization)()>};separator=",\n">
\};
struct l_schedule _<schedule.name> = {<schedule.entryCount>,_<schedule.name>_entries\};
};separator="\n">
static struct l_schedule_instance current = {L_NULL_SCHEDULE,0,0,NULL};
static struct l_schedule_instance next    = {NULL,0,0,NULL};

<else>
static l_u8 NAD = <node.initialNAD.hex>;
static l_u16 supplier_id = <node.supplier.hex>;
static l_u16 function_id = <node.function.hex>;
static l_u8 variant_id = <node.variant>;
static l_u16 break_ticks = 0; // TODO remove this because it is an hardware implementation detail.
<endif>

<node.signals:{signal|static l_bool <signal.name>_flag = false;};separator="\n">

<node.signals:{signal|<signalFlagImplementation(signal)>};separator="\n\n">

<node.publishedSignals:{signal|<signal:(signal.signalType_WriteImplementation)()>};separator="\n\n">

<node.signals:{signal|<signal:(signal.signalType_ReadImplementation)()>};separator="\n\n">

l_bool l_sys_init() {
    tx_buffer.PID = 0xFF;
    tx_buffer.size = 0;
    tx_buffer.index = 0;
    tx_buffer.data.scalar = 0;
    tx_buffer.state = L_IDLE;

    rx_buffer.PID = 0xFF;
    rx_buffer.size = 0;
    rx_buffer.index = 0;
    rx_buffer.data.scalar = 0;
    rx_buffer.state = L_IDLE;

    return false;
}

l_bool l_ifc_init_UART1() {
    //========================================================================//
    AD1PCFGLbits.PCFG4 = 1; // Set RB2 to digital
    AD1PCFGLbits.PCFG5 = 1; // Set RB3 to digital
    TRISBbits.TRISB2  = 0;  // Turn RB2 into output for UART1 TX
    TRISBbits.TRISB3  = 1;  // Turn RB3 into input for UART1 RX
    //========================================================================//

    //========================================================================//
    //Setup peripheral pin select (http://ww1.microchip.com/downloads/en/DeviceDoc/70234B.pdf#page=12)
    //Input setup                 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=130)
    //Output setup                (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=131)

    //Unlock the registers by setting bit 6 of OSCCON to 0 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=110)
    __builtin_write_OSCCONL(OSCCON & ~(1\<\<6));

    //Configure Output Functions
    RPOR1bits.RP2R = 3; //Assign U1TX To Pin RP2

    //Configure Input Functions
    RPINR18bits.U1RXR = 3; //Assign U1RX To Pin RP3
    <if(node.slave)>
    RPINR7bits.IC1R = 3; //Assign IC1 To Pin RP3
    <endif>

    //Lock the registers by setting bit 6 of OSCCON to 1 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=110)
    __builtin_write_OSCCONL(OSCCON | (1\<\<6));
    //========================================================================//

    //========================================================================//
    // Section 21. UART http://ww1.microchip.com/downloads/en/DeviceDoc/en026583.pdf

    // TODO make this adjustable.
    // BRG = FCY    /(4*BAUD_RATE) - 1
    // RGB = 2000000/(4*10000     ) - 1 = 49
    U1BRG = 49; // Set Baud Rate to 10000

    U1MODEbits.BRGH  = 1; // High Baud Rate
    U1MODEbits.PDSEL = 0; // 8-bit data, no parity
    U1MODEbits.STSEL = 0; // One stop bit

    IEC0bits.U1RXIE = 1; // RX interrupt enabled
    IEC0bits.U1TXIE = 1; // TX interrupt enabled
    IPC2bits.U1RXIP = 4; // Level 4 interrupt priority for RX
    IPC3bits.U1TXIP = 4; // Level 4 interrupt priority for TX

    U1STAbits.UTXISEL1 = 1; // Interrupt when the last character is shifted out of the Transmit Shift Register; all transmit operations are completed. Part(1/2)
    U1STAbits.UTXISEL0 = 0; // Part (2/2)

    // TODO URXISEL??

    <if(node.master)>
        U1MODEbits.UARTEN = 1; // Enable the UART 1 module.
    <elseif(node.slave)>
        U1MODEbits.UARTEN = 0; // Disable the UART 1 module until first break.
    <endif>

    IFS0bits.U1TXIF = 0; // Clear the TX interrupt flag
    IFS0bits.U1RXIF = 0; // Clear the RX interrupt flag

    //========================================================================//
<if(node.slave)>

    T1CONbits.TON = 1;
    T1CONbits.TCKPS = 0;
    T1CONbits.TCS = 0;
    T1CONbits.TGATE = 0;
    T1CONbits.TSYNC = 0;

    while(IC1CON1bits.ICBNE != 0)
        (unsigned int)IC1BUF;

    IC1CON1bits.ICSIDL = 0x00;
    IC1CON1bits.ICTSEL = 0x07;
    IC1CON1bits.ICI    = 0x00;
    IC1CON1bits.ICM    = 0x02;

    IC1CON2bits.IC32 = 0x00;
    IC1CON2bits.ICTRIG = 0x01;
    IC1CON2bits.SYNCSEL = 0xb;

    IC1TMR = 0;
    IEC0bits.IC1IE = 1;
    IPC0bits.IC1IP = 7;
<endif>

    return false;
}

static inline void setup_tx(l_u8 PID) {
    tx_buffer.PID = PID;

    if(PID == 0xff) {
        // TODO special
    }
    else if(PID == 0x3C) {
        // TODO master request
    }
    else if(PID == 0x3D) {
        // TODO slave response
    }
<node.frames:{frame|
<if(node.publishes_frame)>
    else if(PID == frames[<frame.name>_INDEX].PID) {
    <if(node.master)>
        tx_buffer.state = L_BREAK_SYNC;
    <else>
        tx_buffer.state = L_DATA;
    <endif>
        tx_buffer.size = <frame.length>;
        tx_buffer.index = 0;

        l_u16 checksum = PID; // TODO check if classic checksum!
        for(l_u8 i=0;i\<<frame.length>;++i) {
            tx_buffer.data.array[i] = frames[<frame.name>_INDEX].data.array[i];
            checksum += frames[<frame.name>_INDEX].data.array[i];
            if(checksum >= 256)
                checksum -= 255;
        \}
        tx_buffer.checksum = (l_u8)~checksum;
    \}
<endif>
}>
    else {
<if(node.master)>
        tx_buffer.state = L_BREAK_SYNC;
<else>
        tx_buffer.state = L_IDLE;
<endif>
        tx_buffer.size  = 0;
        tx_buffer.index = 0;
    }
}

static inline void cleanup_tx() {
    if(tx_buffer.PID == 0xff) {
        // TODO special
    }
    else if(tx_buffer.PID == 0x3C) {
        // TODO master request
    }
    else if(tx_buffer.PID == 0x3D) {
        // TODO slave response
    }
<node.frames:{frame|
<if(node.publishes_frame && frame.signals)>
    else if(tx_buffer.PID == frames[<frame.name>_INDEX].PID) {
<frame.signals:{signal|

        <signal.name>_flag = true;}>
    \}<endif>
}>
    tx_buffer.PID = 0xFF;
    tx_buffer.size = 0;
    tx_buffer.index = 0;
    tx_buffer.data.scalar = 0;
    tx_buffer.state = L_IDLE;
}

void l_ifc_tx_UART1() {
    switch(tx_buffer.state) {
        case L_BREAK_SYNC: {
            tx_buffer.state = L_PID;
            <if(node.master)>
            while(!U1STAbits.TRMT); // Wait for tx to complete.

            // Send the break and sync.
            U1STAbits.UTXBRK = 1; // Enable a break sequence.
            U1STAbits.UTXEN  = 1; // Signal the send 2 clock cycles from now.
            U1TXREG = 0x00;  // Value is ignored.
            U1TXREG = 0x55; // Send the sync character.
            <endif>
            break;
        }
        case L_PID: {
            tx_buffer.state = L_DATA;
            tx_buffer.index = 0;

            <if(node.master)>
            U1STAbits.UTXEN  = 1; // Signal the send 2 clock cycles from now.
            U1TXREG = tx_buffer.PID; // Send the PID.
            <endif>
            break;
        }
        case L_DATA: {
            if(tx_buffer.index \< tx_buffer.size) {
                U1STAbits.UTXEN  = 1; // Signal the send 2 clock cycles from now.
                U1TXREG = tx_buffer.data.array[tx_buffer.index]; // Send the data.
                tx_buffer.index++;
                break;
            }
            else {
                tx_buffer.state = L_CHECKSUM;
            }
            // careful purposefully falling through to L_CHECKSUM!
        }
        case L_CHECKSUM: {
            tx_buffer.state = L_IDLE;
            if(tx_buffer.size > 0) {
                tx_buffer.size  = 0;
                tx_buffer.index = 0;

                U1STAbits.UTXEN  = 1; // Signal the send 2 clock cycles from now.
                U1TXREG = tx_buffer.checksum;

                <if(node.slave)>
                cleanup_tx();
                <endif>
            }
            break;
        }
        case L_IDLE: {
            break;
        }
    }
}

static inline void setup_rx(l_u8 PID) {
    rx_buffer.PID = PID;

    if(PID == 0xff) {
        // TODO special
    }
    else if(PID == 0x3C) {
        // TODO master request
    }
    else if(PID == 0x3D) {
        // TODO slave response
    }
<node.frames:{frame|
<if(!node.publishes_frame)>
    else if(PID == frames[<frame.name>_INDEX].PID) {
        rx_buffer.state = L_DATA;
        rx_buffer.size = <frame.length>;
        rx_buffer.index = 0;
    \}
<endif>
}>
    else {
        rx_buffer.state = L_IDLE;
        rx_buffer.size  = 0;
        rx_buffer.index = 0;
    }
}

static inline void cleanup_rx() {
    if(rx_buffer.PID == 0xff) {
        // TODO special
    }
    else if(rx_buffer.PID == 0x3C) {
        // TODO master request
    }
    else if(rx_buffer.PID == 0x3D) {
        // TODO slave response
    }
<node.frames:{frame|
<if(!node.publishes_frame)>
    else if(rx_buffer.PID == frames[<frame.name>_INDEX].PID) {
        l_u16 checksum = rx_buffer.PID; // TODO check if classic checksum!
        for(l_u8 i=0;i\<<frame.length>;++i) {
            checksum += rx_buffer.data.array[i];
            if(checksum >= 256)
                checksum -= 255;
        \}
        if((l_u8)~checksum == rx_buffer.checksum) {
<frame.signals:{signal|
            <signal.name>_flag = true;
}>
            frames[<frame.name>_INDEX].data.scalar = rx_buffer.data.scalar;
        \}
        else {
            return; // TODO what should happen on error.
        \}
    \}<endif>
}>
    rx_buffer.PID = 0xFF;
    rx_buffer.size = 0;
    rx_buffer.index = 0;
    rx_buffer.data.scalar = 0;
    rx_buffer.state = L_IDLE;
}

void l_ifc_rx_UART1() {
    while(U1STAbits.URXDA) {
        switch(rx_buffer.state) {
            case L_BREAK_SYNC: {
                rx_buffer.state = L_PID;
                <if(node.slave)>
                break_ticks = 44*U1BRG+44;
                <endif>
                break;
            }
            case L_PID: {
                rx_buffer.state = L_DATA;
                rx_buffer.index = 0; // TODO is this needed!

                rx_buffer.PID = (l_u8)U1RXREG;
                <if(node.slave)>

                setup_tx(rx_buffer.PID);
                setup_rx(rx_buffer.PID);
                // TODO wait??
                l_ifc_tx_UART1();
                <endif>

                break;
            }
            case L_DATA: {
                if(rx_buffer.index \< rx_buffer.size) {
                    rx_buffer.data.array[rx_buffer.index] = (l_u8)U1RXREG;
                    rx_buffer.index++;
                    break;
                }
                else {
                    rx_buffer.state = L_CHECKSUM;
                }
                // careful purposefully falling through to L_CHECKSUM!
            }
            case L_CHECKSUM: {
                rx_buffer.state = L_IDLE;
                if(rx_buffer.size > 0) {
                    rx_buffer.checksum = (l_u8)U1RXREG;

                    rx_buffer.size  = 0;
                    rx_buffer.index = 0;
                    <if(node.slave)>
                    cleanup_rx();
                    <endif>
                }
                break;
            }
            case L_IDLE: {
                l_u8 data = (l_u8)U1RXREG; // Just eat the data that this node does not care about!
                break;
            }
        }
    }
}

<if(node.master)>
void l_sch_set_UART1(struct l_schedule *schedule,l_u8 entry) {
    if(schedule != NULL) {
        next.schedule = schedule;
        next.tick     = 0;
        next.index    = (entry > 0) ? entry-1 : 0; // TODO check if the entry is in the schedule??
        next.entry    =  &schedule->entries[next.index];
    }
}

l_u8 l_sch_tick_UART1() {
    if(next.schedule != NULL && current.tick == 0) {
        current = next;
        next.schedule = NULL;
    }

    if(current.schedule == L_NULL_SCHEDULE) {
        return 0;
    }

    struct l_schedule_entry *entry = current.entry;
    switch(entry->type) {
        case UNCONDITIONAL_ENTRY: {
            struct l_frame *frame = entry->data.frame;
            if(current.tick == 0) {
                setup_tx(frame->PID);
                setup_rx(frame->PID);
                l_ifc_tx_UART1();
            }

            if(current.tick >= entry->ticks-1) {
                cleanup_tx();
                cleanup_rx();
                current.tick = 0;
                current.index = (current.index \< current.schedule->size-1) ? current.index+1 : 0;
                current.entry = &current.schedule->entries[current.index];
                return current.index+1;
            }
            break;
        }
        // TODO add the rest!
    }

    current.tick++;
    return 0;
}
<elseif(node.slave)>
void __attribute__((interrupt,no_auto_psv)) _IC1Interrupt() {
    if(IFS0bits.IC1IF) {
        l_u16 time = TMR1;
        TMR1 = 0;
        if(IC1CON1bits.ICM == 0x02) {
            IC1CON1bits.ICM = 0x03;
        }
        else if(IC1CON1bits.ICM == 0x03) {
            if(break_ticks == 0) {
                U1BRG = time/52-1;
                break_ticks = 44*U1BRG+44;
                U1MODEbits.UARTEN = 1;
            }
            if(time >= break_ticks) {
                rx_buffer.state = L_BREAK_SYNC;
                U1MODEbits.ABAUD = 1;
            }
            IC1CON1bits.ICM = 0x02;
        }
        IFS0bits.IC1IF = 0;
    }
}
<endif>

void __attribute__((interrupt,no_auto_psv)) _U1TXInterrupt() {
    if(IFS0bits.U1TXIF) {
        // Clear TX interrupt flag.
        IFS0bits.U1TXIF = 0;

        l_ifc_tx_UART1();

        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}

void __attribute__((interrupt,no_auto_psv)) _U1RXInterrupt() {
    if(IFS0bits.U1RXIF) {
        // Clear RX interrupt flag.
        IFS0bits.U1RXIF = 0;

        l_ifc_rx_UART1();

        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}
>>

boolReadImplementation(signal) ::= <<
l_bool l_bool_rd_<signal.name>() {
    return (l_bool)((frames[<signal.frame.name>_INDEX].data.scalar >\> <signal.offset>) & <signal.signalMask.hex>ULL);
}>>

u8ReadImplementation(signal) ::= <<
l_u8 l_u8_rd_<signal.name>() {
    return (l_u8)((frames[<signal.frame.name>_INDEX].data.scalar >\> <signal.offset>) & <signal.signalMask.hex>ULL);
}>>

u16ReadImplementation(signal) ::= <<
l_u16 l_u16_rd_<signal.name>() {
    return (l_u16)((frames[<signal.frame.name>_INDEX].data.scalar >\> <signal.offset>) & <signal.signalMask.hex>ULL);
}>>

bytesReadImplementation(signal) ::= <<
void l_bytes_rd_<signal.name>(l_u8 start,l_u8 count,l_u8* const data) {
    // TODO check for count being to large??
    for(l_u8 i=0;i\<count;++i)
        data[i] = frames[<signal.frame.name>_INDEX].data[<signal.offset>/8+start+i];
}>>


boolWriteImplementation(signal) ::= <<
void l_bool_wr_<signal.name>(l_bool v) {
    frames[<signal.frame.name>_INDEX].data.scalar &= ~(<signal.signalMask.hex>ULL \<\< <signal.offset>);
    frames[<signal.frame.name>_INDEX].data.scalar |= (((uint64_t)v & <signal.signalMask.hex>ULL) \<\< <signal.offset>);
}>>

u8WriteImplementation(signal) ::= <<
void l_u8_wr_<signal.name>(l_u8 v) {
    frames[<signal.frame.name>_INDEX].data.scalar &= ~(<signal.signalMask.hex>ULL \<\< <signal.offset>);
    frames[<signal.frame.name>_INDEX].data.scalar |= (((uint64_t)v & <signal.signalMask.hex>ULL) \<\< <signal.offset>);
}>>

u16WriteImplementation(signal) ::= <<
void l_u16_wr_<signal.name>(l_u16 v) {
    frames[<signal.frame.name>_INDEX].data.scalar &= ~(<signal.signalMask.hex>ULL \<\< <signal.offset>);
    frames[<signal.frame.name>_INDEX].data.scalar |= (((uint64_t)v & <signal.signalMask.hex>ULL) \<\< <signal.offset>);
}>>

bytesWriteImplementation(signal) ::= <<
void l_bytes_wr_<signal.name>(l_u8 start,l_u8 count,const l_u8* const data) {
    frames[<signal.frame.name>_INDEX].data.scalar &= ~(<signal.signalMask.hex>ULL \<\< <signal.offset>);
    frames[<signal.frame.name>_INDEX].data.scalar |= (((uint64_t)v & <signal.signalMask.hex>ULL) \<\< <signal.offset>);
}>>


signalFlagImplementation(signal) ::= <<
l_bool l_flg_tst_<signal.name>() {
    return <signal.name>_flag;
}

void l_flg_clr_<signal.name>() {
    <signal.name>_flag = false;
}
>>

//====================================================================================================================//
// TODO implement this!
assignFrameIdEntryInitialization(entry) ::= "{.type = ASSIGN_FRAME_ID_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignFrameIdRangeEntryInitialization(entry) ::= "{.type = ASSIGN_FRAME_ID_RANGE_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignNADEntryInitialization(entry) ::= "{.type = ASSIGN_NAD_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
conditionalChangeNADEntryInitialization(entry) ::= "{.type = CONDITIONAL_CHANGE_NAD_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
dataDumpEntryInitialization(entry) ::= "{.type = DATA_DUMP_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
freeFormatEntryInitialization(entry) ::= "{.type = FREE_FORMAT_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
masterReqEntryInitialization(entry) ::= "{.type = MASTER_REQ_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
saveConfigurationEntryInitialization(entry) ::= "{.type = SAVE_CONFIGURATION_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
slaveRespEntryInitialization(entry) ::= "{.type = SLAVE_RESP_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
unconditionalEntryInitialization(entry) ::= "{.type = UNCONDITIONAL_ENTRY,.ticks = <entry.ticks>,.data.frame = &frames[<entry.frame.name>_INDEX]}"
//====================================================================================================================//

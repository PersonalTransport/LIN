import "../common/DriverHeader.stg"

//====================================================================================================================//
masterDriverHeader(cluster) ::= <<
#ifndef <cluster.master.name>_MASTER_DRIVER_H
#define <cluster.master.name>_MASTER_DRIVER_H

#include \<stdlib.h>
#include \<stdint.h>
#include \<stdbool.h>

<commonTypedefs()>

enum l_schedule_entry_type {
    ASSIGN_FRAME_ID_ENTRY,//??
    ASSIGN_FRAME_ID_RANGE_ENTRY,
    ASSIGN_NAD_ENTRY,
    CONDITIONAL_CHANGE_NAD_ENTRY,//??
    //!!DATA_DUMP_ENTRY,
    FREE_FORMAT_ENTRY,//??
    MASTER_REQ_ENTRY,
    SAVE_CONFIGURATION_ENTRY,
    SLAVE_RESP_ENTRY,
    UNCONDITIONAL_ENTRY
};

struct l_schedule_entry {
    enum l_schedule_entry_type type; // TODO could be 4 bit unsigned
    l_u8 ticks;
    union {
        struct l_frame *frame;
        //TODO add others
    } data;
};

struct l_schedule {
    l_u8 size;
    struct l_schedule_entry *entries;
};

extern struct l_schedule _L_NULL_SCHEDULE;
<cluster.master.scheduleTables:{schedule|extern struct l_schedule _<schedule.name>;};separator="\n">

#define L_NULL_SCHEDULE &_L_NULL_SCHEDULE
<cluster.master.scheduleTables:{schedule|#define <schedule.name> &_<schedule.name>};separator="\n">

<cluster.signals:{signal|<signalFlagPrototype(signal)>};separator="\n\n">

<cluster.master.publishedSignals:{signal|<signal:(signal.signalType_WritePrototype)()>};separator="\n\n">

<cluster.signals:{signal|<signal:(signal.signalType_ReadPrototype)()>};separator="\n\n">

l_bool l_sys_init();

l_bool l_ifc_init_UART1();

void l_sch_set_UART1(struct l_schedule *schedule,l_u8 entry);

l_u8 l_sch_tick_UART1();

#endif //<cluster.master.name>_MASTER_DRIVER_H
>>
//====================================================================================================================//


import "../common/DriverSource.stg"

//====================================================================================================================//
masterDriverSource(cluster) ::= <<
#include \<<cluster.master.name>.h>
#include \<xc.h>

#define NOT_SPECIFIED 0
<cluster.nodes:{node|#define <node.name> <i>};separator="\n">

#define L_FRAME_PID(id) (~((id \<\< 6) ^ (id \<\< 4) ^ (id \<\< 3) ^ (id \<\< 2)) & 0x80) |\
                         (((id \<\< 6) ^ (id \<\< 5) ^ (id \<\< 4) ^ (id \<\< 2)) & 0x40) |\
                         (id & 0x3F)

<cluster.frames:{frame|#define <frame.name>_INDEX <i0>};separator="\n">

static struct l_frame frames[] = {
<cluster.frames:{frame|
    {
        .PID = L_FRAME_PID(<frame.ID>),
        .data.scalar = 0ULL // TODO initial data
    \}};separator=",\n">
};

<cluster.signals:{signal|static l_bool <signal.name>_flag;};separator="\n">

struct l_schedule _L_NULL_SCHEDULE = {0,NULL};

<cluster.master.scheduleTables:{schedule|
static struct l_schedule_entry _<schedule.name>_entries[] = {
    <schedule.entries:{entry|<entry:(entry.polymorphic_Initialization)()>};separator=",\n">
\};
struct l_schedule _<schedule.name> = {<schedule.entryCount>,_<schedule.name>_entries\};
};separator="\n">
<cluster.signals:{signal|<signalFlagImplementation(signal)>};separator="\n\n">

<cluster.master.publishedSignals:{signal|<signal:(signal.signalType_WriteImplementation)()>};separator="\n\n">

<cluster.signals:{signal|<signal:(signal.signalType_ReadImplementation)()>};separator="\n\n">

l_bool l_sys_init() {
    return false;
}

enum l_buffer_state {
    L_BREAK_SYNC,
    L_PID,
    L_DATA,
    L_CHECKSUM,
    L_IDLE
};

static struct {
    enum l_buffer_state state;
    l_u8 PID;
    union {
        l_u8 array[8];
        uint64_t scalar;
    } data;
    l_u8 checksum;
    l_u8 size;
    l_u8 index;
} tx_buffer, rx_buffer;

l_bool l_ifc_init_UART1() {
    <commonUART1Setup()>
    U1MODEbits.UARTEN = 1; // Enable the UART 1 module
    return false;
}

<txUART1Implementation(cluster.master)>

<rxUART1Implementation(cluster.master)>

struct l_schedule_instance {
    struct l_schedule *schedule;
    l_u8 tick;
    l_u8 index;
    struct l_schedule_entry *entry;
};

static struct l_schedule_instance current = {L_NULL_SCHEDULE,0,0,NULL};
static struct l_schedule_instance next    = {NULL,0,0,NULL};

void l_sch_set_UART1(struct l_schedule *schedule,l_u8 entry) {
    if(schedule != NULL) {
        next.schedule = schedule;
        next.tick     = 0;
        next.index    = (entry > 0) ? entry-1 : 0; // TODO check if the entry is in the schedule??
        next.entry    =  &schedule->entries[next.index];
    }
}

l_u8 l_sch_tick_UART1() {
    if(next.schedule != NULL && current.tick == 0) {
        current = next;
        next.schedule = NULL;
    }

    if(current.schedule == L_NULL_SCHEDULE) {
        return 0;
    }

    struct l_schedule_entry *entry = current.entry;
    switch(entry->type) {
        case UNCONDITIONAL_ENTRY: {
            struct l_frame *frame = entry->data.frame;
            if(current.tick == 0) {
                setup_tx(frame->PID);
                setup_rx(frame->PID);
                l_ifc_tx_UART1();
            }

            if(current.tick >= entry->ticks-1) {
                // TODO copy data over!
                cleanup_tx();
                cleanup_rx();
                current.tick = 0;
                current.index = (current.index \< current.schedule->size-1) ? current.index+1 : 0;
                current.entry = &current.schedule->entries[current.index];
                return current.index+1;
            }
            break;
        }
        // TODO add the rest!
    }

    current.tick++;
    return 0;
}

void __attribute__((interrupt,no_auto_psv)) _U1TXInterrupt() {
    if(IFS0bits.U1TXIF) {
        // Clear TX interrupt flag.
        IFS0bits.U1TXIF = 0;

        l_ifc_tx_UART1();

        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}

void __attribute__((interrupt,no_auto_psv)) _U1RXInterrupt() {
    if(IFS0bits.U1RXIF) {
        // Clear RX interrupt flag.
        IFS0bits.U1RXIF = 0;

        l_ifc_rx_UART1();

        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}
>>
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignFrameIdEntryInitialization(entry) ::= "{.type = ASSIGN_FRAME_ID_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignFrameIdRangeEntryInitialization(entry) ::= "{.type = ASSIGN_FRAME_ID_RANGE_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignNADEntryInitialization(entry) ::= "{.type = ASSIGN_NAD_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
conditionalChangeNADEntryInitialization(entry) ::= "{.type = CONDITIONAL_CHANGE_NAD_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
dataDumpEntryInitialization(entry) ::= "{.type = DATA_DUMP_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
freeFormatEntryInitialization(entry) ::= "{.type = FREE_FORMAT_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
masterReqEntryInitialization(entry) ::= "{.type = MASTER_REQ_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
saveConfigurationEntryInitialization(entry) ::= "{.type = SAVE_CONFIGURATION_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
slaveRespEntryInitialization(entry) ::= "{.type = SLAVE_RESP_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
unconditionalEntryInitialization(entry) ::= "{.type = UNCONDITIONAL_ENTRY,.ticks = <entry.ticks>,.data.frame = &frames[<entry.frame.name>_INDEX]}"
//====================================================================================================================//

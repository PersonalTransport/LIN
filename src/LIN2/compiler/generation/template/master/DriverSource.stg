import "../common/DriverSource.stg"

//====================================================================================================================//
masterDriverSource(cluster) ::= <<
#include \<<cluster.master.name>.h>
#include \<xc.h>

#define NOT_SPECIFIED 0
<cluster.nodes:{node|#define <node.name> <i>};separator="\n">

#define L_FRAME_PID(id) (~((id \<\< 6) ^ (id \<\< 4) ^ (id \<\< 3) ^ (id \<\< 2)) & 0x80) |\
                         (((id \<\< 6) ^ (id \<\< 5) ^ (id \<\< 4) ^ (id \<\< 2)) & 0x40) |\
                         (id & 0x3F)

<cluster.frames:{frame|#define <frame.name>_INDEX <i0>};separator="\n">

static struct l_frame frames[] = {
<cluster.frames:{frame|
    {
        .PID = L_FRAME_PID(<frame.ID>),
        .length = <frame.length>,
        .publisher = <if(frame.publisher)><frame.publisher.name><else>NOT_SPECIFIED<endif>,
        .data.scalar = 0ULL // TODO initial data
    \}};separator=",\n">
};

<cluster.signals:{signal|static l_bool <signal.name>_flag;};separator="\n">

struct l_schedule _L_NULL_SCHEDULE = {0,NULL};

<cluster.master.scheduleTables:{schedule|
static struct l_schedule_entry _<schedule.name>_entries[] = {
    <schedule.entries:{entry|<entry:(entry.polymorphic_Initialization)()>};separator=",\n">
\};
struct l_schedule _<schedule.name> = {<schedule.entryCount>,_<schedule.name>_entries\};
};separator="\n">
<cluster.signals:{signal|<signalFlagImplementation(signal)>};separator="\n\n">

<cluster.master.publishedSignals:{signal|<signal:(signal.signalType_WriteImplementation)()>};separator="\n\n">

<cluster.signals:{signal|<signal:(signal.signalType_ReadImplementation)()>};separator="\n\n">

l_bool l_sys_init() {
    return false;
}

enum l_buffer_state {
    L_BREAK_SYNC,
    L_PID,
    L_DATA,
    L_CHECKSUM,
    L_IDLE
};

static struct {
    enum l_buffer_state state;
    l_u8 PID;
    union {
        l_u8 array[8];
        uint64_t scalar;
    } data;
    l_u8 checksum;
    l_u8 size;
    l_u8 index;
} tx_buffer, rx_buffer;

l_bool l_ifc_init_UART1() {
    <commonUART1Setup()>
    U1MODEbits.UARTEN = 1; // Enable the UART 1 module
    return false;
}

struct l_schedule_instance {
    struct l_schedule *schedule;
    l_u8 tick;
    l_u8 index;
    struct l_schedule_entry *entry;
};

static struct l_schedule_instance current = {L_NULL_SCHEDULE,0,0,NULL};
static struct l_schedule_instance next    = {NULL,0,0,NULL};

void l_sch_set_UART1(struct l_schedule *schedule,l_u8 entry) {
    if(schedule != NULL) {
        next.schedule = schedule;
        next.tick     = 0;
        next.index    = (entry > 0) ? entry-1 : 0; // TODO check if the entry is in the schedule??
        next.entry    =  &schedule->entries[next.index];
    }
}

l_u8 l_sch_tick_UART1() {
    if(next.schedule != NULL && current.tick == 0) {
        current = next;
        next.schedule = NULL;
    }

    if(current.schedule == L_NULL_SCHEDULE) {
        return 0;
    }

    struct l_schedule_entry *entry = current.entry;
    switch(entry->type) {
        case UNCONDITIONAL_ENTRY: {
            struct l_frame *frame = entry->data.frame;
            if(current.tick == 0) {
                tx_buffer.data[0] = frame->PID;
                l_u16 checksum = frame->PID; // TODO check if frame is classic checksum!

                tx_buffer.size = 1;
                tx_buffer.index = 0;

                if(frame->publisher == <cluster.master.name>) {
                    l_u8 frame_length = frame->length;
                    for(l_u8 i=0;i\<frame_length;++i) {
                        tx_buffer.data[i+1] = frame->data.array[i];
                        checksum += frame->data.array[i];
                        if(checksum >= 256)
                            checksum = checksum - 255;
                    }
                    tx_buffer.data[frame_length+1] = (l_u8)~checksum;
                    tx_buffer.size = 2 + frame_length;
                }

                while(!U1STAbits.TRMT); // Wait for tx to complete.

                // Send the break and sync.
                U1STAbits.UTXBRK = 1; // Enable a break sequence.
                U1STAbits.UTXEN  = 1; // Signal the send 2 clock cycles from now.
                U1TXREG = 0x00;  // Value is ignored.
                U1TXREG = 0x55; // Send the sync character.
            }

            if(current.tick >= entry->ticks-1) {
                // TODO read RX data
                current.tick = 0;
                current.index = (current.index \< current.schedule->size-1) ? current.index+1 : 0;
                current.entry = &current.schedule->entries[current.index];
                return current.index+1;
            }
            break;
        }
        // TODO add the rest!
    }

    current.tick++;
    return 0;
}

void __attribute__((interrupt,no_auto_psv)) _U1TXInterrupt() {
    if(IFS0bits.U1TXIF) {
        // Clear TX interrupt flag.
        IFS0bits.U1TXIF = 0;
        if(tx_buffer.index \< tx_buffer.size) {
            l_u8 data = tx_buffer.data[tx_buffer.index];
            U1STAbits.UTXEN = 1; // Signal the send 2 clock cycles from now.
            U1TXREG = data;
            tx_buffer.index++;
        }
    }
}

void __attribute__((interrupt,no_auto_psv)) _U1RXInterrupt() {
    if(IFS0bits.U1RXIF) {
        // Clear RX interrupt flag.
        IFS0bits.U1RXIF = 0;
    }
}
>>
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignFrameIdEntryInitialization(entry) ::= "{.type = ASSIGN_FRAME_ID_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignFrameIdRangeEntryInitialization(entry) ::= "{.type = ASSIGN_FRAME_ID_RANGE_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignNADEntryInitialization(entry) ::= "{.type = ASSIGN_NAD_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
conditionalChangeNADEntryInitialization(entry) ::= "{.type = CONDITIONAL_CHANGE_NAD_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
dataDumpEntryInitialization(entry) ::= "{.type = DATA_DUMP_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
freeFormatEntryInitialization(entry) ::= "{.type = FREE_FORMAT_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
masterReqEntryInitialization(entry) ::= "{.type = MASTER_REQ_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
saveConfigurationEntryInitialization(entry) ::= "{.type = SAVE_CONFIGURATION_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
slaveRespEntryInitialization(entry) ::= "{.type = SLAVE_RESP_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
unconditionalEntryInitialization(entry) ::= "{.type = UNCONDITIONAL_ENTRY,.ticks = <entry.ticks>,.data.frame = &frames[<entry.frame.name>_INDEX]}"
//====================================================================================================================//

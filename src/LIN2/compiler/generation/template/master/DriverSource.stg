import "../common/DriverSource.stg"

//====================================================================================================================//
masterDriverSource(cluster) ::= <<
#include \<<cluster.master.name>.h>
#include \<xc.h>

<driverCommon(cluster.master)>

enum l_schedule_entry_type {
    ASSIGN_FRAME_ID_ENTRY,//??
    ASSIGN_FRAME_ID_RANGE_ENTRY,
    ASSIGN_NAD_ENTRY,
    CONDITIONAL_CHANGE_NAD_ENTRY,//??
    //!!DATA_DUMP_ENTRY,
    FREE_FORMAT_ENTRY,//??
    MASTER_REQ_ENTRY,
    SAVE_CONFIGURATION_ENTRY,
    SLAVE_RESP_ENTRY,
    UNCONDITIONAL_ENTRY
};

struct l_schedule_entry {
    enum l_schedule_entry_type type; // TODO could be 4 bit unsigned
    l_u8 ticks;
    union {
        struct l_frame *frame; // TODO change to PID!
        //TODO add others
    } data;
};

struct l_schedule {
    l_u8 size;
    struct l_schedule_entry *entries;
};


struct l_schedule _L_NULL_SCHEDULE = {0,NULL};

<cluster.master.scheduleTables:{schedule|
static struct l_schedule_entry _<schedule.name>_entries[] = {
    <schedule.entries:{entry|<entry:(entry.polymorphic_Initialization)()>};separator=",\n">
\};
struct l_schedule _<schedule.name> = {<schedule.entryCount>,_<schedule.name>_entries\};
};separator="\n">

l_bool l_sys_init() {
    return false;
}

l_bool l_ifc_init_UART1() {
    <commonUART1Setup()>
    U1MODEbits.UARTEN = 1; // Enable the UART 1 module
    return false;
}

<txUART1Implementation(cluster.master)>

<rxUART1Implementation(cluster.master)>

struct l_schedule_instance {
    struct l_schedule *schedule;
    l_u8 tick;
    l_u8 index;
    struct l_schedule_entry *entry;
};

static struct l_schedule_instance current = {L_NULL_SCHEDULE,0,0,NULL};
static struct l_schedule_instance next    = {NULL,0,0,NULL};

void l_sch_set_UART1(struct l_schedule *schedule,l_u8 entry) {
    if(schedule != NULL) {
        next.schedule = schedule;
        next.tick     = 0;
        next.index    = (entry > 0) ? entry-1 : 0; // TODO check if the entry is in the schedule??
        next.entry    =  &schedule->entries[next.index];
    }
}

l_u8 l_sch_tick_UART1() {
    if(next.schedule != NULL && current.tick == 0) {
        current = next;
        next.schedule = NULL;
    }

    if(current.schedule == L_NULL_SCHEDULE) {
        return 0;
    }

    struct l_schedule_entry *entry = current.entry;
    switch(entry->type) {
        case UNCONDITIONAL_ENTRY: {
            struct l_frame *frame = entry->data.frame;
            if(current.tick == 0) {
                setup_tx(frame->PID);
                setup_rx(frame->PID);
                l_ifc_tx_UART1();
            }

            if(current.tick >= entry->ticks-1) {
                cleanup_tx();
                cleanup_rx();
                current.tick = 0;
                current.index = (current.index \< current.schedule->size-1) ? current.index+1 : 0;
                current.entry = &current.schedule->entries[current.index];
                return current.index+1;
            }
            break;
        }
        // TODO add the rest!
    }

    current.tick++;
    return 0;
}

void __attribute__((interrupt,no_auto_psv)) _U1TXInterrupt() {
    if(IFS0bits.U1TXIF) {
        // Clear TX interrupt flag.
        IFS0bits.U1TXIF = 0;

        l_ifc_tx_UART1();

        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}

void __attribute__((interrupt,no_auto_psv)) _U1RXInterrupt() {
    if(IFS0bits.U1RXIF) {
        // Clear RX interrupt flag.
        IFS0bits.U1RXIF = 0;

        l_ifc_rx_UART1();

        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}
>>
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignFrameIdEntryInitialization(entry) ::= "{.type = ASSIGN_FRAME_ID_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignFrameIdRangeEntryInitialization(entry) ::= "{.type = ASSIGN_FRAME_ID_RANGE_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
assignNADEntryInitialization(entry) ::= "{.type = ASSIGN_NAD_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
conditionalChangeNADEntryInitialization(entry) ::= "{.type = CONDITIONAL_CHANGE_NAD_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
dataDumpEntryInitialization(entry) ::= "{.type = DATA_DUMP_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
freeFormatEntryInitialization(entry) ::= "{.type = FREE_FORMAT_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
masterReqEntryInitialization(entry) ::= "{.type = MASTER_REQ_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
saveConfigurationEntryInitialization(entry) ::= "{.type = SAVE_CONFIGURATION_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
slaveRespEntryInitialization(entry) ::= "{.type = SLAVE_RESP_ENTRY,.ticks = <entry.ticks>}"
//====================================================================================================================//


//====================================================================================================================//
// TODO implement this!
unconditionalEntryInitialization(entry) ::= "{.type = UNCONDITIONAL_ENTRY,.ticks = <entry.ticks>,.data.frame = &frames[<entry.frame.name>_INDEX]}"
//====================================================================================================================//

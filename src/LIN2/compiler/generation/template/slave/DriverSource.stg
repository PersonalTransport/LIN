import "../common/DriverSource.stg"

//====================================================================================================================//
slaveDriverSource(slave) ::= <<
#include \<<slave.name>.h>
#include \<xc.h>

<driverCommon(slave)>

l_bool l_sys_init() {
    return false;
}

l_u16 break_ticks = 0;

l_bool l_ifc_init_UART1() {
    <commonUART1Setup()>

    T1CONbits.TON = 1;
    T1CONbits.TCKPS = 0;
    T1CONbits.TCS = 0;
    T1CONbits.TGATE = 0;
    T1CONbits.TSYNC = 0;

    //Unlock the registers by setting bit 6 of OSCCON to 0 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=110)
    __builtin_write_OSCCONL(OSCCON & ~(1\<\<6));

    //Configure Input Functions
    //RPINR18bits.U1RXR = 3; //Assign U1RX To Pin RP3
    RPINR7bits.IC1R = 3; //Assign IC1 To Pin RP3

    //Lock the registers by setting bit 6 of OSCCON to 1 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=110)
    __builtin_write_OSCCONL(OSCCON | (1\<\<6));

    while(IC1CON1bits.ICBNE != 0)
        (unsigned int)IC1BUF;

    IC1CON1bits.ICSIDL = 0x00;
    IC1CON1bits.ICTSEL = 0x07;
    IC1CON1bits.ICI    = 0x00;
    IC1CON1bits.ICM    = 0x02;

    IC1CON2bits.IC32 = 0x00;
    IC1CON2bits.ICTRIG = 0x01;
    IC1CON2bits.SYNCSEL = 0xb;

    IC1TMR = 0;
    IEC0bits.IC1IE = 1;
    IPC0bits.IC1IP = 7;

    rx_buffer.state = L_IDLE;

    return false;
}

<txUART1Implementation(slave)>

<rxUART1Implementation(slave)>

void __attribute__((interrupt,no_auto_psv)) _U1TXInterrupt() {
    if(IFS0bits.U1TXIF) {
        // Clear TX interrupt flag.
        IFS0bits.U1TXIF = 0;

        l_ifc_tx_UART1();

        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}

void __attribute__((interrupt,no_auto_psv)) _U1RXInterrupt() {
    if(IFS0bits.U1RXIF) {
        // Clear RX interrupt flag.
        IFS0bits.U1RXIF = 0;

        l_ifc_rx_UART1();

        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}

void __attribute__((interrupt,no_auto_psv)) _IC1Interrupt() {
    if(IFS0bits.IC1IF) {
        l_u16 time = TMR1;
        TMR1 = 0;
        if(IC1CON1bits.ICM == 0x02) {
            IC1CON1bits.ICM = 0x03;
        }
        else if(IC1CON1bits.ICM == 0x03) {
            if(break_ticks == 0) {
                U1BRG = time/52-1;
                break_ticks = 44*U1BRG+44;
                U1MODEbits.UARTEN = 1;
            }
            if(time >= break_ticks) {
                rx_buffer.state = L_BREAK_SYNC;
                U1MODEbits.ABAUD = 1;
            }
            IC1CON1bits.ICM = 0x02;
        }
        IFS0bits.IC1IF = 0;
    }
}

>>
//====================================================================================================================//

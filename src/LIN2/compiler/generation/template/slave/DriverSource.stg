import "../common/DriverSource.stg"

//====================================================================================================================//
slaveDriverSource(slave) ::= <<
#include \<<slave.name>.h>
#include \<xc.h>

#define NOT_SPECIFIED 0
#define <slave.name> 1

#define L_FRAME_PID(id) (~((id \<\< 6) ^ (id \<\< 4) ^ (id \<\< 3) ^ (id \<\< 2)) & 0x80) |\
                         (((id \<\< 6) ^ (id \<\< 5) ^ (id \<\< 4) ^ (id \<\< 2)) & 0x40) |\
                         (id & 0x3F)

<slave.frames:{frame|#define <frame.name>_INDEX <i0>};separator="\n">

static struct l_frame frames[] = {
<slave.frames:{frame|
    {   // <frame.name>
        .PID = L_FRAME_PID(<frame.ID>),
        .length = <frame.length>,
        .publisher = <if(slave.publishes_frame)><slave.name><else>NOT_SPECIFIED<endif>,
        .data.scalar = 0ULL // TODO initial data
    \}};separator=",\n">
};

<slave.signals:{signal|static l_bool <signal.name>_flag;};separator="\n">

<slave.signals:{signal|<signalFlagImplementation(signal)>};separator="\n\n">

<slave.publishedSignals:{signal|<signal:(signal.signalType_WriteImplementation)()>};separator="\n\n">

<slave.signals:{signal|<signal:(signal.signalType_ReadImplementation)()>};separator="\n\n">

l_bool l_sys_init() {
    return false;
}

enum l_buffer_state {
    L_BREAK_SYNC,
    L_PID,
    L_DATA,
    L_CHECKSUM,
    L_IDLE
};

static struct {
    enum l_buffer_state state;
    l_u8 PID;
    l_u8 data[8];
    l_u8 size;
    l_u8 index;
} rx_buffer;

l_u16 break_ticks = 0;

l_bool l_ifc_init_UART1() {
    <commonUART1Setup()>

    T1CONbits.TON = 1;
    T1CONbits.TCKPS = 0;
    T1CONbits.TCS = 0;
    T1CONbits.TGATE = 0;
    T1CONbits.TSYNC = 0;

    //Unlock the registers by setting bit 6 of OSCCON to 0 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=110)
    __builtin_write_OSCCONL(OSCCON & ~(1\<\<6));

    //Configure Input Functions
    //RPINR18bits.U1RXR = 3; //Assign U1RX To Pin RP3
    RPINR7bits.IC1R = 3; //Assign IC1 To Pin RP3

    //Lock the registers by setting bit 6 of OSCCON to 1 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=110)
    __builtin_write_OSCCONL(OSCCON | (1\<\<6));

    while(IC1CON1bits.ICBNE != 0)
        (unsigned int)IC1BUF;

    IC1CON1bits.ICSIDL = 0x00;
    IC1CON1bits.ICTSEL = 0x07;
    IC1CON1bits.ICI    = 0x00;
    IC1CON1bits.ICM    = 0x02;

    IC1CON2bits.IC32 = 0x00;
    IC1CON2bits.ICTRIG = 0x01;
    IC1CON2bits.SYNCSEL = 0xb;

    IC1TMR = 0;
    IEC0bits.IC1IE = 1;
    IPC0bits.IC1IP = 7;

    rx_buffer.state = L_IDLE;

    return false;
}

void __attribute__((interrupt,no_auto_psv)) _U1TXInterrupt() {
    if(IFS0bits.U1TXIF) {
        // Clear TX interrupt flag.
        IFS0bits.U1TXIF = 0;
    }
}

void __attribute__((interrupt,no_auto_psv)) _U1RXInterrupt() {
    if(IFS0bits.U1RXIF) {
        // Clear RX interrupt flag.
        IFS0bits.U1RXIF = 0;

        if(rx_buffer.state == L_BREAK_SYNC) {
            rx_buffer.state = L_PID;
            rx_buffer.size = 0;
            rx_buffer.index = 0;
            break_ticks = 44*U1BRG+44;
        }

        while(U1STAbits.URXDA) {
            switch(rx_buffer.state) {
                case L_PID: {
                    rx_buffer.PID = (l_u8)U1RXREG;

                    <slave.frames:{frame|<subscribe(slave,frame)>};separator="\nelse ">
                    else {
                        rx_buffer.state = L_IDLE;
                        rx_buffer.size = 0;
                        rx_buffer.index = 0;
                    }
                    break;
                }
                case L_DATA: {
                    if(rx_buffer.index \< rx_buffer.size) {
                        rx_buffer.data[rx_buffer.index] = (l_u8)U1RXREG;;
                        rx_buffer.index++;
                    }
                    else {
                        rx_buffer.state = L_CHECKSUM;
                    }
                    break;
                }
                case L_CHECKSUM: {
                    rx_buffer.state = L_IDLE;
                    l_u8 checksum = (l_u8)U1RXREG;
                    // TODO check the checksum!
                    break;
                }
                case L_IDLE: {
                    l_u8 data = (l_u8)U1RXREG; // Just eat the data that this node does not care about!
                    break;
                }
            }
        }
        if(U1STAbits.FERR)
            U1STAbits.FERR = 0;
    }
}

void __attribute__((interrupt,no_auto_psv)) _IC1Interrupt() {
    if(IFS0bits.IC1IF) {
        l_u16 time = TMR1;
        TMR1 = 0;
        if(IC1CON1bits.ICM == 0x02) {
            IC1CON1bits.ICM = 0x03;
        }
        else if(IC1CON1bits.ICM == 0x03) {
            if(break_ticks == 0) {
                U1BRG = time/52-1;
                break_ticks = 44*U1BRG+44;
                U1MODEbits.UARTEN = 1;
            }
            if(time >= break_ticks) {
                rx_buffer.state = L_BREAK_SYNC;
                U1MODEbits.ABAUD = 1;
            }
            IC1CON1bits.ICM = 0x02;
        }
        IFS0bits.IC1IF = 0;
    }
}

>>
//====================================================================================================================//

subscribe(slave,frame) ::= <<
if(rx_buffer.PID == frames[<frame.name>_INDEX].PID) {
<if(slave.publishes_frame)>
    rx_buffer.state = L_IDLE;
    rx_buffer.size = 0;
    rx_buffer.index = 0;
<else>
    rx_buffer.state = L_DATA;
    rx_buffer.size = <frame.length>;
    rx_buffer.index = 0;
<endif>
}
>>
targetIncludes(node,interface,target) ::= <<
#include \<xc.h>

#ifndef FCY
#error "FCY must be defined while compiling <node.name>.c"
#endif

#define MIN_BAUD 10000
#define MAX_BAUD 20000

#if (13*FCY/MIN_BAUD)  > 0xFFFF
    #error "FCY/MAX_BAUD is too large for a 16-bit timer!"
#endif
>>

targetGlobals(node,interface,target) ::= ""

systemInitialization(node,interface,target) ::= <<
// TODO implement!
>>

interfaceGlobals(node,interface,target) ::= <<
<if(node.slave)>
static l_u16 break_ticks_<interface.name> = 0;

void __attribute__((interrupt,no_auto_psv)) _IC1Interrupt() {
    if(IFS0bits.IC1IF) {
        l_u16 time = TMR1;
        TMR1 = 0;
        if(IC1CON1bits.ICM == 0x02) {
            IC1CON1bits.ICM = 0x03;
        }
        else if(IC1CON1bits.ICM == 0x03) {
            if(break_ticks_<interface.name> == 0) {
            <interface.baudRateRegister> = time/52-1; // TODO this does not look right
                break_ticks_<interface.name> = 44*<interface.baudRateRegister>+44; // TODO this does not look right
                <interface.modeRegister>.UARTEN = 1;
            }
            if(time >= break_ticks_<interface.name>) {
                rx_buffer.state = L_BREAK_SYNC;
                <interface.modeRegister>.ABAUD = 1;
            }
            IC1CON1bits.ICM = 0x02;
        }
        IFS0bits.IC1IF = 0;
    }
}
<endif>
>>

interfaceInitialization(node,interface,target) ::= <<

//========================================================================//
#if defined(PIC24FJxxGBxxx)
AD1PCFGL = 0xFFFF;
#elif defined(PIC24FJxxGAxxx)
AD1PCFG = 0xFFFF;
#endif

TRISBbits.TRISB4  = 0; // Turn RB4 into output for CS/LWAKE
TRISBbits.TRISB7  = 0; // Turn RB7 into output for !FAULT/TXE
TRISBbits.TRISB15 = 0;  // Turn RB15 into output for UART1 TX
TRISBbits.TRISB3  = 1;  // Turn RB3 into input for UART1 RX
//========================================================================//

//========================================================================//
//Setup peripheral pin select (http://ww1.microchip.com/downloads/en/DeviceDoc/70234B.pdf#page=12)
//Input setup                 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=130)
//Output setup                (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=131)

//Unlock the registers by setting bit 6 of OSCCON to 0 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=110)
__builtin_write_OSCCONL(OSCCON & ~(1\<\<6));

//Configure Output Functions
RPOR7bits.RP15R = <interface.outputFunction>; //Assign U1TX To Pin RP15

//Configure Input Functions
<interface.inputFunction> = 3; //Assign U1RX To Pin RP3
<if(node.slave)>
RPINR7bits.IC1R = 3; //Assign IC1 To Pin RP3
<endif>

//Lock the registers by setting bit 6 of OSCCON to 1 (http://ww1.microchip.com/downloads/en/DeviceDoc/39940d.pdf#page=110)
__builtin_write_OSCCONL(OSCCON | (1\<\<6));
//========================================================================//

//========================================================================//
// Section 21. UART http://ww1.microchip.com/downloads/en/DeviceDoc/en026583.pdf

// TODO make this adjustable.
// BRG = FCY    /(4*BAUD_RATE) - 1
// RGB = 2000000/(4*10000     ) - 1 = 49
<interface.baudRateRegister> = 49; // Set Baud Rate to 10000

<interface.modeRegister>.BRGH  = 1; // High Baud Rate
<interface.modeRegister>.PDSEL = 0; // 8-bit data, no parity
<interface.modeRegister>.STSEL = 0; // One stop bit

<interface.statusRegister>.UTXISEL1 = 1; // Interrupt when the last character is shifted out of the Transmit Shift Register; all transmit operations are completed. Part(1/2)
<interface.statusRegister>.UTXISEL0 = 0; // Part (2/2)

<interface.statusRegister>.URXISEL1 = 0;
<interface.statusRegister>.URXISEL0 = 0;

// TODO URXISEL??

l_sys_irq_disable();
<if(node.master)>
<interface.modeRegister>.UARTEN = 1; // Enable the UART 1 module.
<elseif(node.slave)>
<interface.modeRegister>.UARTEN = 0; // Disable the UART 1 module until first break.
<endif>
//========================================================================//
<if(node.slave)>

//========================================================================//
// Timer 1 for break detection.
T1CONbits.TON = 1;
T1CONbits.TCKPS = 0;
T1CONbits.TCS = 0;
T1CONbits.TGATE = 0;
T1CONbits.TSYNC = 0;

while(IC1CON1bits.ICBNE != 0)
    (unsigned int)IC1BUF;

IC1CON1bits.ICSIDL = 0x00;
IC1CON1bits.ICTSEL = 0x07;
IC1CON1bits.ICI    = 0x00;
IC1CON1bits.ICM    = 0x02;

IC1CON2bits.IC32 = 0x00;
IC1CON2bits.ICTRIG = 0x01;
IC1CON2bits.SYNCSEL = 0xB;

IC1TMR = 0;
//========================================================================//
<endif>

// Force MCP2050 into operation mode
LATBbits.LATB4 = 1;
LATBbits.LATB7 = 1;
>>

interfaceRxDataAvailable(node,interface,target) ::= "<interface.statusRegister>.URXDA"

interfaceRxData(cVarToStoreIn,node,interface,target) ::= "<cVarToStoreIn> = (l_u8)<interface.rxRegister>;"

interfaceRxBreakSync(node,interface,target) ::= "break_ticks_<interface.name> = 44 * <interface.baudRateRegister> + 44;" // TODO this does not look right

interfaceTxData(cVarToTx,node,interface,target) ::= <<
<interface.statusRegister>.UTXEN  = 1; // Signal the send 2 clock cycles from now.
<interface.txRegister> = (l_u8)<cVarToTx>;
>>

interfaceTxBreakAndSync(node,interface,target) ::= <<
// Send the break and sync.
while(!<interface.statusRegister>.TRMT); // Wait for tx to complete.
<interface.statusRegister>.UTXBRK = 1; // Enable a break sequence.
<interface.statusRegister>.UTXEN  = 1; // Signal the send 2 clock cycles from now.
<interface.txRegister> = 0x00;  // Value is ignored.
<interface.txRegister> = 0x55; // Send the sync character.
>>
